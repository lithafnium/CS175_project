<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Tetris: CS 175 Project</title>
    <link rel="stylesheet" href="./style.css" />
    <link href="./prism.css" rel="stylesheet" />

    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
  </head>
  <body>
    <main>
      <div class="container">
        <div class="container-inner">
          <h1>CS 175 Project: Tetris</h1>
          <p class="italics">By Steve Li and Elizabeth Ling</p>
          <h2>Background</h2>
          <p>
            Tetris, a puzzle game created by Soviet Engineer Alexey Pajitnov,
            has captivated audiences since the 1980s. First starting out on
            early computers such as the Electronika 60, the game quickly grew in
            popularity, and practically any device with a screen mostly likely
            has the capability to run the game. Within this project, we aim to
            bring the game to the modern medium, a 3D stylized version built
            using Unity using the concepts learned in class.
          </p>
          <h2>Tetris Basics</h2>
          <h3>Rules</h3>
          <p>
            The game is rather simple. On a 10x20 grid of squares, players
            attempt to stack individual pieces, named
            <span class="italics bold">tetrominoes</span>, on top of each other.
            Filling an entire row of blocks
            <span class="italics bold">clears</span> the row of blocks, bringing
            every other block above it down a row. If the stack of blocks reach
            the very top, the game ends. Furthermore, as more lines are cleared,
            the game is sped up. The goal, therefore, is to clear as many rows
            before the stack reaches the top of the board.
          </p>
          <h3>Tetrominoes</h3>
          <p>
            A tetromino is a geometric shape composed of 4 squares. In a
            standard game of tetris, the player is presented with 7 tetrominoes,
            indicated by the letter the shape draws out: I, L, J, T, O, S, and
            Z.
          </p>
          <div class="image-grid">
            <img class="image" src="html_images/I.png" />
            <img class="image" src="html_images/L.png" />
            <img class="image" src="html_images/J.png" />
            <img class="image" src="html_images/T.png" />
            <img class="image" src="html_images/O.png" />
            <img class="image" src="html_images/S.png" />
            <img class="image" src="html_images/Z.png" />
          </div>
          <p>
            Within our implementation of Tetris, we created the 3D models of
            each piece ourselves, and then applied a color material that matched
            that of the standard Tetris color sceheme.
          </p>
          <p>
            The key compnonent of tetrominoes lies in the rotation system. In
            the Super Rotation System, or SRS, the current Tetris standard for
            how tetrominoes behave when rotated, the following rules are in
            place, taken from the Tetris wiki:
          </p>
          <ul>
            <li>
              When unobstructed, the tetrominoes all appear to rotate purely
              about a single point. These apparent rotation centers are shown as
              circles in the diagram.
            </li>
            <li>
              It is a pure rotation in a mathematical sense, as opposed to the
              combination of rotation and translation found in other systems
              such as Sega Rotation and Atari Rotation.
            </li>
            <li>
              For the I and O tetrominoes, the apparent rotation center is at
              the intersection of gridlines, whereas for the J, L, S, T and Z
              tetrominoes, the rotation center coincides with the center of one
              of the four constituent blocks.
            </li>
          </ul>
          <div class="captaioned-image">
            <img
              class="image"
              style="width: 40%"
              src="html_images/rotation.png"
            />
            <p class="italics">
              The rotation states of all 7 tetrominioes according to SRS
            </p>
          </div>
          <p>
            Our rotation system attempted to emulate SRS as best as possible,
            placing the rotation point towards the center of the piece. With the
            I and O tetrominoes, we simply disabled rotation of the O piece, and
            the I piece we chose a block close to the center as the rotation
            point.
          </p>
          <div class="captaioned-image">
            <img
              class="image"
              style="width: 50%"
              src="html_images/I_center.png"
            />
            <p class="italics">The pivot point of the I piece.</p>
          </div>
          <h3>DAS and ARR</h3>
          <p>
            Another component of tetrominioes lies in their movement, also known
            as <span class="italics bold">finesse</span> in the Tetris
            community. Two settings are commonly used in most Tetris ports,
            known as DAS and ARR. DAS stands for
            <span class="bold">Delayed Auto Shift</span>, and represents the
            delay in which a piece will move when the player continues to hold a
            key. On the other hand, ARR stands for
            <span class="bold">Auto Repeat Rate</span>, which means the rate at
            which pieces move in their intended direction. Both of these were
            implemented and are tuneable with individual parameters in our C#
            scripts, allowing for players to adjust their piece handling
            capabilities. More details will be outlined below.
          </p>
          <h1>Unity Implementation (the fun stuff)</h1>
          <div class="captaioned-image">
            <img class="image" style="width: 90%" src="html_images/board.png" />
            <p class="italics">Our beautiful board.</p>
          </div>
          <h2>Board Design</h2>
          <p>
            Board design is fairly simple. In the center we drew a 10x20 grid
            outlined by 3D cubes. On the top left, we outline a square meant to
            display the "held" piece (will outline in a later section). During
            actual game play, the right part of the screen is filled with the
            next 5 upcoming pieces, allowing players to plan ahead their stacks.
          </p>
          <h2>Board Representation</h2>
          <p>
            On top of the 3D board drawn in Unity, we also represented our board
            as a 20x10 array of <code>Transform</code> objects, notably so that
            we can perform transofmrations on individual blocks rather easily.
          </p>
          <pre><code class="language-csharp">public Transform[,] grid = new Transform[h, w]; 
</code></pre>
          <p>
            Using this array representation is useful, as it simplifies our
            workflow considerably. Therefore, for each frame, we perform the
            following:
          </p>
          <ol>
            <li>
              For each piece movement, we first check if the piece is inside the
              grid or colliding with another piece. This requires looping
              through each individual cube of the active tetromino, converting
              its piece-world coordinates to array positions using rounding, and
              then checking the grid if the spot at the specified row and column
              is null or not. This is implemented in the function
              <code>checkBoardPosition()</code> under <code>Piece.cs</code>.
              <ul>
                <li>
                  Checking if a board position is occupied is as simple as
                  checking if an individual square's
                  <span class="italics bold">parent</span> is not equal to the
                  current tetromino. This is because in the scene graph, each
                  individual cube is a child of a tetromino, and we set each
                  item in the array to be the children of the tetrominioes.
                </li>
              </ul>
            </li>
            <li>
              If the array position is free, that is, all cubes of the active
              piece are not occupying any space, then we move the piece to its
              specified location.
            </li>
            <li>
              Upon moving the piece, we set the piece's new location in the
              array by looping through the piece's children, converting its
              coordinates to array positions, and setting the array to be the
              child object. We also set its old locations to null.
            </li>
          </ol>
          <p>
            When a piece is placed, we need to check whether any rows are
            filled. This is accomplished by first getting all filled rows,
            destroying all the <code>Transform</code> objects in the array, and
            then moving all rows above the filled row down by one position,
            shifting each cube down by 1 on the y-axis.
          </p>
          <h2>Piece Movement</h2>
          <p></p>
          <h2>Upcoming Pieces</h2>
          <h2>Piece Spawning</h2>
          <pre><code class="language-csharp">public void spawnTetrominoe(
            bool first, 
            GameObject spawn, 
            int id, 
            bool drawUpcomingPiece
          ) {

  if (spawn == null) {
      if (first) {
          var (piece, index) = getRandomPiece(); 
          spawn = piece; 
          id = index; 
      } else {
          spawn = this.upcoming[0]; 
          id = this.upcomingIds[0];
      }
  }

  Debug.Log("Spawning: " + spawn); 
  this.current = instantiatePiece(spawn, 
                                  true, 
                                  new Vector3(-0.5f, 18, 0), id);
  if (drawUpcomingPiece) drawUpcoming(false);

}</code></pre>

          <p>
            Within <code>TetrisBoard.cs</code>, we have the function
            <code>spawnTetrominoe()</code> that's
          </p>
        </div>
      </div>
    </main>
    <script src="index.js"></script>
    <script src="prism.js"></script>
  </body>
</html>
